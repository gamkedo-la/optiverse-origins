<html>

<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>


// ##################################
// Global Variables
// ##################################

var canvas;
var ctx;

const LIGHTSPEED = 0;
const DASHED_LINE_LENGTH = 10; // must be >1, not sure if decimals do anything


// ##################################
// ON LOAD
// ##################################

window.onload = function() {
	canvas = document.getElementById('gameCanvas');
	ctx = canvas.getContext('2d');

	var framesPerSecond = 30;
	setInterval(function() {
			moveEverything();
			drawEverything();	
		}, 1000/framesPerSecond);

	canvas.addEventListener('mousedown', 
		function(evt) {
			var mousePos = calculateMousePos(evt);
			handleMouseClick(mousePos);
		});
	
	/*
	canvas.addEventListener('mousemove',
		function(evt) {
			var mousePos = calculateMousePos(evt);
		}); 
	*/
}


// ##################################
// USER INPUT
// ##################################

function calculateMousePos(evt) {
	var rect = canvas.getBoundingClientRect();
	var root = document.documentElement;
	var mouseX = evt.clientX - rect.left - root.scrollLeft;
	var mouseY = evt.clientY - rect.top - root.scrollTop;
	return {
		x:mouseX,
		y:mouseY
	};
}

function handleMouseClick(mousePos) {
	// Check for click on cores
	for (var i=0; i < cores.length; i++) {
		core = cores[i];
		if (core.encloses(mousePos.x, mousePos.y)){
			core.explode();
		}
	}
	
	
}


// ##################################
// Helper Functions
// ##################################

// crosses
// surrounds

// Dot product of two vectors
function dotproduct(a,b) {
	// Args: a = [x1,y1], b = [x2,y2]
	var n = 0, lim = Math.min(a.length,b.length);
	for (var i = 0; i < lim; i++) n += a[i] * b[i];
	return n;
}

 // Normalize a vector
function normalize(vector) {
	// Args: vector = [x1,y1]
	var n = 0, vectorLength, result = [];
	
	for (var i = 0; i < vector.length; i++) {
	    n += Math.pow(vector[i],2);
	}
	
	vectorLength = Math.sqrt(n);
		
	for (var i = 0; i < vector.length; i++) {
	    result.push(vector[i] / vectorLength);
	}
	
	return result;
}
 

function distance_between_two_points(x0, y0, x1, y1) {
    var deltaX = x1 - x0;
    var deltaY = y1 - y0;
    return Math.hypot(deltaX, deltaY);
    
}

// Helper for function intersect()
function ccw(A,B,C) {  
        return Boolean( (C[1]-A[1]) * (B[0]-A[0]) > (B[1]-A[1]) * (C[0]-A[0]) ); 
}

// Line intersection test
function lines_intersect(L1, L2) {
    // Return true if lines L1 and L2 intersect
    var A = [L1.startX, L1.startY];
    var B = [L1.endX, L1.endY];    
    
    var C = [L2.startX, L2.startY];
    var D = [L2.endX, L2.endY];   
     
    return Boolean(ccw(A,C,D) != ccw(B,C,D) && ccw(A,B,C) != ccw(A,B,D));
}

// Intersection point
function intersection_point(line1, line2) {
    // Returns point of intersection between two Line objects
        
   var line1StartX = line1.startX; 
   var line1StartY = line1.startY; 
   var line1EndX = line1.endX; 
   var line1EndY = line1.endY;
   var line2StartX = line2.startX; 
   var line2StartY = line2.startY;
   var line2EndX = line2.endX;
   var line2EndY = line2.endY;
   
    // FROM THE INTERWEBS!!! http://jsfiddle.net/justin_c_rounds/Gd2S2/
    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
    var denominator, a, b, numerator1, numerator2, result = {
        x: null,
        y: null,
        onLine1: false,
        onLine2: false
    };
    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - 
		      ((line2EndX - line2StartX) * (line1EndY - line1StartY));
    if (denominator == 0) {
        return result;
    }
    a = line1StartY - line2StartY;
    b = line1StartX - line2StartX;
    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
    a = numerator1 / denominator;
    b = numerator2 / denominator;

    // if we cast these lines infinitely in both directions, they intersect here:
    result.x = line1StartX + (a * (line1EndX - line1StartX));
    result.y = line1StartY + (a * (line1EndY - line1StartY));

        // it is worth noting that this should be the same as:
        // x = line2StartX + (b * (line2EndX - line2StartX));
        // y = line2StartX + (b * (line2EndY - line2StartY));
        
    // if line1 is a segment and line2 is infinite, they intersect if:
    if (a > 0 && a < 1) {
        result.onLine1 = true;
    }
    // if line2 is a segment and line1 is infinite, they intersect if:
    if (b > 0 && b < 1) {
        result.onLine2 = true;
    }
    // if line1 and line2 are segments, they intersect if both of the above are true
    return result;
}



// Vector reflection in 2D
function reflect_vector(vector, mirror_line) {
    // Args: vector = [x1,y1], mirror_line = [x2,y2]
    
    // Receives two vectors represented as arrays (same origin), 
    // and returns point, mirror of 'vector' around 'mirror_line'.
    
    var nhat, result = {x: null, y: null};
    nhat = normalize(mirror_line); // Normalized mirror line
    
    result.x = 2 * dotproduct(vector, nhat) * nhat[0] - vector[0];
    result.y = 2 * dotproduct(vector, nhat) * nhat[1] - vector[1];
    
    return result;    
}


// ##################################
// Classes (Prototype Constructors)
// ##################################

// ----------------------------------
// Lines
// ----------------------------------

// === Line =========================
function Line(startX, startY, endX, endY, color, lineWidth) {
	this.color = color;
	this.lineWidth = lineWidth;
	this.startX = startX;
	this.startY = startY;
	this.endX = endX;
	this.endY = endY;
}

// intersects()
Line.prototype.intersects = function (line) { 
	// receives line object and tests intersection
	return Boolean(intersect(this, line))
}	
// draw()
Line.prototype.draw = function () {
	colorLine(this.startX, this.startY, 
		 this.endX, this.endY, 
		 this.color, this.lineWidth);
}


// === MirrorLine =========================
function MirrorLine(startX, startY, endX, endY, color, lineWidth) {
	// Call parent constructor	
	Line.call(this, startX, startY, endX, endY, color, lineWidth);				
} // Make it a subclass
MirrorLine.prototype = Object.create(Line.prototype); 
MirrorLine.prototype.constructor = MirrorLine; 
// move()
MirrorLine.prototype.move = function (deltaX, deltaY) {
	// TO DO
}
// reflect()
MirrorLine.prototype.reflect = function (vector) {
	var result = {newX: null,
		      newY: null,
		      intersectX: null,
		      intersectY: null,
		      newDirection: null};
	// Calculate intersection point
	var point = intersection_point(this, vector);
	
	result.intersectX = point.x;
	result.intersectY = point.y;
	
	// Create vectors using intersect as origin, and calculate reflection
	remainingTrajectory = [vector.endX - point.x, vector.endY - point.y];
	mirrorLine = [this.endX - point.x, this.endY - point.y];
	delta = reflect_vector(remainingTrajectory, mirrorLine);
	// Add delta to origin to get result
	result.newX = point.x + delta.x;
	result.newY = point.y + delta.y;
	
	// Use trig to calculate new direction
	result.newDirection = (Math.atan(delta.y/delta.x) * (180/Math.PI)) % 360;
	
	return result;
}						

// ----------------------------------
// Line Groups and Polygons
// ----------------------------------

/* TO DO
// === MirrorLineGroup =========================
function MirrorLineGroup(centerX, centerY, color, lineWidth) {
	this.color = color;
	this.lineWidth = lineWidth;
	this.mirrorLines = [];
	this.centerX = centerX;
	this.centerY = centerY;
}
// setLines()
MirrorLineGroup.prototype.setLines = function (points) {
	// Receives a set of x,y coordinates for a series of lines
	// relative to centerX and centerY
	if (points.length%2 != 0 || points.length < 4) {
		console.log("Error: 'points' has odd number of elements");
	}
	var startX = points[0];
	var startY = points[1];
	var endX;
	var endY;
	var mirror;
	
	for(i=1; i < points.length/2; i++){
		endX = points[2*i];
		endY = points[2*i + 1];
		mirror = new MirrorLine(startX, startY, endX, endY, 
				    this.color, this.lineWidth);
		startX = endX;
		startY = endY;
		
		this.mirrorLines.push(mirror);	
	}
}
// draw()
MirrorLineGroup.prototype.draw = function () {
	for(var i=0; i < this.mirrorLines.length; i++){
		this.mirrorLines[i].draw();
	}
}
*/



// === Trail =========================
function Trail(trailLength, color, lineWidth) {
	this.trailLength = trailLength;
	this.color = color;
	this.lineWidth = lineWidth;

	this.lines = [];
}
// addNewLine()
Trail.prototype.addLine = function (startX, startY, endX, endY) {
	var line = new Line(startX, startY, endX, endY, color, lineWidth);
	this.lines.push(line);
	while (this.lines.length > this.trailLength){
		var temp = this.lines.shift() //Get rid of oldest line
		// temp is throwaway, not used
	}
}
// draw()
Trail.prototype.draw = function () {
	for(var i=0; i < this.trailLength; i++){
		if (i < this.lines.length) {
			this.lines[i].draw();
		}
	}
}



// ----------------------------------
// Laser Beams
// ----------------------------------

// === Beam =========================
function Beam(posX, posY, speed, direction, trailLength, color, lineWidth) {

	this.posX = posX;
	this.posY = posY;
	this.speed = speed;
	this.direction = direction;
	this.active = true; // boolean	
	
	this.trail = new Trail(this, trailLength, color, lineWidth);
	
	// Previous state
	this.prevX = posX;
	this.prevY = posY;
	this.prevDirection = direction;
	this.intersectX = null;
	this.intersectY = null;
}
// updateBEAM()
Beam.prototype.updateBEAM = function () {
	if (!this.active){
		return;
	}
	
	// Update previous info
	this.prevX = this.posX;
	this.prevY = this.posY;
	this.prevDirection = this.direction;
	
	// Calculate new position
	this.posX += this.getSpeedX();
	this.posY += this.getSpeedY();
	
	this.trail.addLine(this.prevX, this.prevY, this.);
	
	// create line of most recent step
	var line_step = {startX: this.prevX, 
		      startY: this.prevY,
		      endX: this.posX, 
		      endY: this.posY, 
		      direction: this.direction};
	
	// mirror collisions 
	for (var i=0; i < mirrors.length; i++) {
	
		if(lines_intersect(mirrors[i], line_step)){
			// Reflect off of mirror
			reflection = mirrors[i].reflect(line_step);
			
			// Save values
			this.intersectX = reflection.intersectX;
			this.intersectY = reflection.intersectY;
			this.posX = reflection.newX;
			this.posY = reflection.newY;
			this.direction = reflection.newDirection;
		}
	}
	
		
	
	// lens collisions
	/* for (var i=0; i < lenses.length; i++) {
		if(lines_intersect(lenses[i], ){
			
		}
	}*/
	
	// other object collisions
}
// getSpeedX()
Beam.prototype.getSpeedX = function () {
	var speedX = this.speed * Math.cos(this.direction * Math.PI/180);
	return speedX;
}
// getSpeedY()
Beam.prototype.getSpeedY = function () {
	var speedY = this.speed * Math.sin(this.direction * Math.PI/180);
	return speedY;
}
Beam.prototype.draw = function () {
	this.trail.draw();
}

// ----------------------------------
// Cores and Sources
// ----------------------------------

// === Core =========================
function Core(centerX, centerY, innerRadius, outerRadius, color, coreRings) {
	// Args: coreRings = []
	this.centerX = centerX;
	this.centerY = centerY;
	this.innerRadius = innerRadius;
	this.outerRadius = outerRadius;
	this.color = color;
	this.coreRings = coreRings; // an array of CoreRing objects
}
// updateCORE()
Core.prototype.updateCORE = function () {

	for (var i=0; i < this.coreRings.length; i++) {	
		this.coreRings[i].updateRING();	 // update each ring
	}	
}
// isFull()
Core.prototype.isFull = function () {
	for (var i=0; i < this.coreRings.length; i++) {
		if (!(this.coreRings[i].isActive())) {
			return false;
		}
	}
	return true;
}
// explode()
Core.prototype.explode = function () {
	for (var i=0; i < this.coreRings.length; i++) {
		var ring = this.coreRings[i];
		if (ring.isActive()) {
			ring.deactivate();
			// fire laser beam
			
			// TODO
		} else {
			ring.activate();
		}
	}
}
// absorb()
Core.prototype.absorb = function (beam) {
	var absorbed = false;
	for (var i=0; i < this.coreRings.length; i++) {
		var ring = this.coreRings[i];
		if (!(ring.isActive()) && beam.color == ring.color) {
			ring.activate();
			return;
		}
	}
	if (!absorbed) {
		// broken core
		// TO DO
		return;
	}
}
// encloses()
Core.prototype.encloses = function (x, y) {
	// Call helper function
	var dist = distance_between_two_points(this.centerX, this.centerY, x, y);
	return Boolean(this.outerRadius - dist > 0);
}
// draw()
Core.prototype.draw = function () {
	
	// Core circle
	colorCircle(this.centerX, this.centerY, this.innerRadius, this.color);
	
	// Core levels
	for(var i=0; i < this.coreRings.length; i++){
		var ring = this.coreRings[i];
		if (ring.isActive()) {
			ring.draw(this.centerX, this.centerY);
		}
	}
}


// === CoreRing =========================
function CoreRing(radius, frequency, amplitude, color, lineWidth) {
	this.radius = radius;
	this.frequency = frequency;
	this.amplitude = amplitude;
	this.radiusChange = 0; 
	this.degreeOffset = 0; // 0-359 degrees
	this.active = false;
	
	this.color = color;
	this.lineWidth = lineWidth;	
}
// updateRING()
CoreRing.prototype.updateRING = function () {
	if (this.active){
		this.degreeOffset = (this.degreeOffset + this.frequency) % 360;
		// var radiansOffset = this.degreeOffset * Math.PI/180;
		this.radiusChange = this.amplitude * Math.sin(this.degreeOffset);
	}
}
// isActive()
CoreRing.prototype.isActive = function () {
	return this.active;
}
// activate()
CoreRing.prototype.activate = function () {
	this.active = true;
}
// deactivate()
CoreRing.prototype.deactivate = function () {
	this.active = false;
}
// draw()
CoreRing.prototype.draw = function (centerX, centerY) {
	var rad = this.radius + this.radiusChange;
	strokeCircle(centerX, centerY, rad, this.color, this.lineWidth);
}



// ------------------------------------

// ##################################
// Gameplay
// ##################################



// Mirrors
var mirrorLineWidth = 6;
var mirror1 = new MirrorLine(0, 300, 600, 0, 'gray', mirrorLineWidth);

var mirrors = [mirror1];

// @@@@@@@@@@@@@@@@@@
console.log(mirrors);
// @@@@@@@@@@@@@@@@@@


//Cores

var dashLineWidth = 2;

var pos1x = 50;
var pos1y = 50;
var angle1 = 45;
var dash1 = 2;
var CR1 = new CoreRing(20, .04, 1, 'red', 3);
CR1.activate();
var arr1 = [CR1];
var core1 = new Core(pos1x, pos1y, 7, 20, 'red', arr1);


var pos2x = 200;
var pos2y = 300;
var angle2 = 0;
var dash2 = 5;
var CR2 = new CoreRing(25, .08, 1, 'green', 5);
CR2.activate();
var arr2 = [CR2];
var core2 = new Core(pos2x, pos2y, 10, 20, 'green', arr2);

var pos3x = 250;
var pos3y = 50;
var angle3 = 90;
var dash3 = 10;
var CR3r = new CoreRing(20, .04, 1, 'red', 3);
CR3r.activate();
var CR3b = new CoreRing(40, .1, 1, 'blue', 5);
CR3b.activate();
var arr3 = [CR3b, CR3r];
var core3 = new Core(pos3x, pos3y, 10, 20, 'purple', arr3);

trailLength = 10;

var beam1 = new Beam(50,300, LIGHTSPEED, 270, trailLength, 'red', dashLineWidth);
var beam2 = new Beam(50,300, LIGHTSPEED, 0, trailLength, 'green', dashLineWidth);
var beam3 = new Beam(50,300, LIGHTSPEED, 315, trailLength, 'purple', dashLineWidth);


//Accumulate

var cores = [core2, core1, core3];
var beams = [beam1, beam2, beam3];

// @@@@@@@@@@@@@@@@@@
console.log(beams);
// @@@@@@@@@@@@@@@@@@


function moveEverything() {
	
	// ---------------------
	// Beams
	// ---------------------
	for (var i=0; i < beams.length; i++) {
		beams[i].updateBEAM();
	}
	
	// ---------------------
	// Mouse tractor beam 
	// ---------------------
	
	
	// ---------------------
	// CORES
	// ---------------------
	// update core rings
	for (var i=0; i < cores.length; i++) {
		cores[i].updateCORE();
	}
}


// ##################################
// DRAW
// ##################################

function drawEverything() {
	// next line blanks out the screen with black
	colorRect(0,0,canvas.width,canvas.height,'black');
	
	// Cores
	for (var i=0; i < cores.length; i++) {
		cores[i].draw();
	}
	
	
	// Beams
	for (var i=0; i < beams.length; i++) {
		beams[i].draw();
	}
	
	// Mirrors

	for (var i=0; i < mirrors.length; i++) {
		mirrors[i].draw();
	}
}

// Draws line on canvas from (x0, y0) to (x1, y1)
function colorLine(x0, y0, x1, y1, drawColor, lineWidth) {
	ctx.strokeStyle = drawColor;
	ctx.lineWidth = lineWidth;
	
	ctx.beginPath();
	ctx.moveTo(x0, y0);
	ctx.lineTo(x1, y1);
	ctx.stroke();
	ctx.lineCap="round";
}


function colorCircle(centerX, centerY, radius, drawColor) {
	ctx.fillStyle = drawColor;
	ctx.beginPath();
	ctx.arc(centerX, centerY, radius, 0, Math.PI*2,true);
	ctx.fill();
}

function strokeCircle(centerX, centerY, radius, drawColor, lineWidth) {
	ctx.strokeStyle = drawColor;
	ctx.lineWidth = lineWidth;
	
	ctx.beginPath();
	ctx.arc(centerX, centerY, radius, 0, Math.PI*2,true);
	ctx.stroke();
}

function colorRect(leftX, topY, width, height, drawColor) {
	ctx.fillStyle = drawColor;
	ctx.fillRect(leftX, topY, width, height);
}



</script>

</html>