<html>

<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>


// ##################################
// Global Variables
// ##################################

var canvas;
var ctx;

const LIGHTSPEED = 6;
const DASHED_LINE_LENGTH = 10; // must be >1, not sure if decimals do anything

var radius = 10;


// ##################################
// ON LOAD
// ##################################

window.onload = function() {
	canvas = document.getElementById('gameCanvas');
	ctx = canvas.getContext('2d');

	var framesPerSecond = 60;
	setInterval(function() {
			moveEverything();
			drawEverything();	
		}, 1000/framesPerSecond);

	canvas.addEventListener('mousedown', 
		function(evt) {
			var mousePos = calculateMousePos(evt);
			handleMouseClick(mousePos);
		});
	
	/*
	canvas.addEventListener('mousemove',
		function(evt) {
			var mousePos = calculateMousePos(evt);
		}); 
	*/
}


// ##################################
// USER INPUT
// ##################################

function calculateMousePos(evt) {
	var rect = canvas.getBoundingClientRect();
	var root = document.documentElement;
	var mouseX = evt.clientX - rect.left - root.scrollLeft;
	var mouseY = evt.clientY - rect.top - root.scrollTop;
	return {
		x:mouseX,
		y:mouseY
	};
}

function handleMouseClick(mousePos) {
	// Check for click on cores
	for (var i=0; i < cores.length; i++) {
		core = cores[i];
		if (core.encloses(mousePos.x, mousePos.y)){
			core.explode();
		}
	}
	
	
}


// ##################################
// Helper Functions
// ##################################

// crosses
// surrounds

//
function distance_between_two_points(x0, y0, x1, y1) {
    var deltaX = x1 - x0;
    var deltaY = y1 - y0;
    return Math.hypot(deltaX, deltaY);
    
}

// Helper for function intersect()
function ccw(A,B,C) {  
        return Boolean( (C[1]-A[1]) * (B[0]-A[0]) > (B[1]-A[1]) * (C[0]-A[0]) ); 
}

// Line intersection test
function lines_intersect(L1, L2) {
    // Return true if lines L1 and L2 intersect
    var A = [L1.startX, L1.startY];
    var B = [L1.endX, L1.endY];    
    
    var C = [L2.startX, L2.startY];
    var D = [L2.endX, L2.endY];   
     
    return Boolean(ccw(A,C,D) != ccw(B,C,D) && ccw(A,B,C) != ccw(A,B,D));
}

// Intersection point
function intersection_point(line1, line2) {
    // Returns point of intersection between two Line objects
        
    var denominator, numerator1, numerator2, a, b, c;
    var result = {x: null, y: null};
    
    denominator = ((line2.endY - line2.startY) * (line1.endX - line1.startX)) - 
		  ((line2.endX - line2.startX) * (line1.endY - line1.startY));
    if (denominator == 0) {
        return result;
    }
    a = line1.startY - line2.startY;
    b = line1.startX - line2.startX;
    numerator1 = ((line2.endX - line2.startX) * a) - ((line2.endY - line2.startY) * b);
    numerator2 = ((line1.endX - line1.startX) * a) - ((line1.endY - line1.startY) * b);
    c = numerator1 / denominator;
    
    result.x = line1.startX + (a * (line1.endX - line1.startX));
    result.y = line1.startY + (a * (line1.endY - line1.startY));    
    
    return result;
 
}

/* FUNCTION FROM THE INTERNET
function checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
    var denominator, a, b, numerator1, numerator2, result = {
        x: null,
        y: null,
        onLine1: false,
        onLine2: false
    };
    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
    if (denominator == 0) {
        return result;
    }
    a = line1StartY - line2StartY;
    b = line1StartX - line2StartX;
    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
    a = numerator1 / denominator;
    b = numerator2 / denominator;

    // if we cast these lines infinitely in both directions, they intersect here:
    result.x = line1StartX + (a * (line1EndX - line1StartX));
    result.y = line1StartY + (a * (line1EndY - line1StartY));

        // it is worth noting that this should be the same as:
        // x = line2StartX + (b * (line2EndX - line2StartX));
        // y = line2StartX + (b * (line2EndY - line2StartY));
        
    // if line1 is a segment and line2 is infinite, they intersect if:
    if (a > 0 && a < 1) {
        result.onLine1 = true;
    }
    // if line2 is a segment and line1 is infinite, they intersect if:
    if (b > 0 && b < 1) {
        result.onLine2 = true;
    }
    // if line1 and line2 are segments, they intersect if both of the above are true
    return result;
};*/


// ##################################
// Classes (Prototype Constructors)
// ##################################

// ----------------------------------
// Lines and Polygons
// ----------------------------------

// === Line =========================
function Line(startX, startY, endX, endY, color, lineWidth) {
	this.color = color;
	this.lineWidth = lineWidth;
	this.startX = startX;
	this.startY = startY;
	this.endX = endX;
	this.endY = endY;
}
// setStart()
Line.prototype.setStart = function (startX, startY) {
	this.startX = startX;
	this.startY = startY;
}
// getStartX()
Line.prototype.getStartX = function () {
	return this.startX;
}
// getStartY()
Line.prototype.getStartY = function () {
	return this.startY;
}
// setEnd()
Line.prototype.setEnd = function (endX, endY) {
	this.endX = endX;
	this.endY = endY;
}
// getEndX()
Line.prototype.getEndX = function () {
	return this.endX;
}
// getEndY()
Line.prototype.getEndY = function () {
	return this.endY;
}
// intersects()
Line.prototype.intersects = function (line) { 
	// receives line object and tests intersection
	return Boolean(intersect(this, line))
}	
// draw()
Line.prototype.draw = function () {
	colorLine(this.startX, this.startY, 
		 this.endX, this.endY, 
		 this.color, this.lineWidth);
}


// === MirrorLine =========================
function MirrorLine(startX, startY, endX, endY, color, lineWidth) {
	// Call parent constructor	
	Line.call(this, startX, startY, endX, endY, color, lineWidth);				
} // Make it a subclass
MirrorLine.prototype = Object.create(Line.prototype); 
MirrorLine.prototype.constructor = MirrorLine; 
// move()
MirrorLine.prototype.move = function (deltaX, deltaY) {
	// TO DO
}
// reflect()
MirrorLine.prototype.reflect = function (vector) {
	var result = {newX: null,
		      newY: null,
		      intersectX: null,
		      intersectY: null,
		      newDirection: null};
	// Calculate intersection point
	var point = intersection_point(this, vector);
	
	result.intersectX = point.x;
	result.intersectY = point.y;
	
	// Use trig to calculate new direction
	
	
	// Move correct distance in that direction to get new position
	
	
	return result;
}						


// === MirrorLineGroup =========================
function MirrorLineGroup(centerX, centerY, color, lineWidth) {
	this.color = color;
	this.lineWidth = lineWidth;
	this.mirrorLines = [];
	this.centerX = centerX;
	this.centerY = centerY;
}
// setLines()
MirrorLineGroup.prototype.setLines = function (points) {
	// Receives a set of x,y coordinates for a series of lines
	// relative to centerX and centerY
	if (points.length%2 != 0 || points.length < 4) {
		console.log("Error: 'points' has odd number of elements");
	}
	var startX = points[0];
	var startY = points[1];
	var endX;
	var endY;
	var mirror;
	
	for(i=1; i < points.length/2; i++){
		endX = points[2*i];
		endY = points[2*i + 1];
		mirror = new MirrorLine(startX, startY, endX, endY, 
				    this.color, this.lineWidth);
		startX = endX;
		startY = endY;
		
		this.mirrorLines.append(mirror);	
	}
}
// draw()
MirrorLineGroup.prototype.draw = function () {
	for(var i=0; i < this.mirrorLines.length; i++){
		this.mirrorLines[i].draw();
	}
}


// === Trail =========================
function Trail(ballObj, trailLength, color, lineWidth) {
	this.ballObj = ballObj; //Ballistic object to trail
	this.trailLength = trailLength;
	this.color = color;
	this.lineWidth = lineWidth;

	this.lines = [];
}
// updateTRAIL()
Trail.prototype.updateTRAIL = function () {
	var prevX = this.ballObj.getPrevX();
	var prevY = this.ballObj.getPrevY();	
	var intersectX = this.ballObj.getIntersectX();
	var intersectY = this.ballObj.getIntersectY();
	this.ballObj.nullIntersectX();
	this.ballObj.nullIntersectY();
	var newX = this.ballObj.getX();
	var newY = this.ballObj.getY();
	
	if (intersectX != null && intersectY != null){
		var newLine1 = new Line(prevX, prevY, intersectX, intersectY, 
				this.color, this.lineWidth);
		var newLine2 = new Line(intersectX, intersectY, newX, newY, 
				this.color, this.lineWidth);
		this.addNewLine(newLine1);
		this.addNewLine(newLine2);
	} else {
		var newLine = new Line(prevX, prevY, newX, newY, 
					this.color, this.lineWidth);	
		this.addNewLine(newLine);
	}
	
}
// addNewLine()
Trail.prototype.addNewLine = function (newLine) {
	this.lines.push(newLine);
	if (this.lines.length > this.trailLength){
		var temp = this.lines.shift() //Get rid of oldest line
		// temp is throwaway
	}
}
// draw()
Trail.prototype.draw = function () {
	for(var i=0; i < this.trailLength; i++){
		if (i < this.lines.length) {
			this.lines[i].draw();
		}
	}
}

// ----------------------------------
// Velocity
// ----------------------------------

// === Velocity =========================
function Velocity(speed, direction) {
// Speed (float) and direction in degrees (0-359)

	this.speed = speed;
	this.direction = direction % 360;
}
// setSpeed()
Velocity.prototype.setSpeed = function (speed) {
	this.speed = speed;
}
// getSpeed()
Velocity.prototype.getSpeed = function () {
	return this.speed;
}
// getSpeedX()
Velocity.prototype.getSpeedX = function () {
	var speedX = this.speed * Math.cos(this.direction * Math.PI/180);
	return speedX;
}
// getSpeedY()
Velocity.prototype.getSpeedY = function () {
	var speedY = this.speed * Math.sin(this.direction * Math.PI/180);
	return speedY;
}
// setDirection()
Velocity.prototype.setDirection = function (direction) {
	this.direction = direction % 360;
}
// getDirection()
Velocity.prototype.getDirection = function () {
	return this.direction;
}


// ----------------------------------
// Ballistic Objects
// ----------------------------------

// === BallisticObject =========================
function BallisticObject(posX, posY, speed, direction) {

	this.posX = posX;
	this.posY = posY;
	this.prevX = posX;
	this.prevY = posY;
	this.intersectX = null;
	this.intersectY = null;
	this.prevDirection = direction;
	this.velocity = new Velocity(speed, direction);
	this.active = false; // boolean	
}
// updateOBJ()
BallisticObject.prototype.updateOBJ = function () {
	if (!this.active){
		return;
	}
	this.prevX = this.posX;
	this.prevY = this.posY;
	this.prevDirection = this.velocity.getDirection();
	this.posX += this.velocity.getSpeedX();
	this.posY += this.velocity.getSpeedY();
	
	// create vector of most recent step
	var vector = {startX: this.prevX, 
		      startY: this.prevY,
		      endX: this.posX, 
		      endY: this.posY, 
		      direction: this.velocity.getDirection()};
	
	// mirror collisions
	for (var i=0; i < mirrors.length; i++) {
	
		if(lines_intersect(mirrors[i], vector)){
			// Reflect off of mirror
			reflection = mirrors[i].reflect(vector);
			
			// Save values
			this.intersectX = reflection.intersectX;
			this.intersectY = reflection.intersectY;
			this.posX = reflection.newX;
			this.posY = reflection.newY;
			this.velocity.setDirection(reflection.newDirection);
			
			//
			
			return; // Only one event can occur
		}
	}
	
	// lens collisions
	/* for (var i=0; i < lenses.length; i++) {
		if(lines_intersect(lenses[i], ){
			
		}
	}*/
}
// setSpeed()
BallisticObject.prototype.setSpeed = function (speed) {
	this.velocity.setSpeed(speed);
}
// getSpeed()
BallisticObject.prototype.getSpeed = function () {
	return this.velocity.getSpeed();
}
// setPosition()
BallisticObject.prototype.setPosition = function (posX, posY) {
	this.posX = posX;
	this.posY = posY;
}
// getX()
BallisticObject.prototype.getX = function () {
	return this.posX;
}
// getY()
BallisticObject.prototype.getY = function () {
	return this.posY;
}
// getPrevX()
BallisticObject.prototype.getPrevX = function () {
	return this.prevX;
}
// getPrevY()
BallisticObject.prototype.getPrevY = function () {
	return this.prevY;
}
// getIntersectX()
BallisticObject.prototype.getIntersectX = function () {
	return this.intersectX;
}
// nullIntersectX()
BallisticObject.prototype.nullIntersectX = function () {
	this.intersectX = null;
}
// getIntersectY()
BallisticObject.prototype.getIntersectY = function () {
	return this.intersectY;
}
// nullIntersectY()
BallisticObject.prototype.nullIntersectY = function () {
	this.intersectY = null;
}
// getDirection()
BallisticObject.prototype.getDirection = function () {
	return this.velocity.getDirection();
}
// getPrevDirection()
BallisticObject.prototype.getPrevDirection = function () {
	return this.prevDirection;
}
// activate()
BallisticObject.prototype.activate = function () {
	this.active = true;
}
// isActive()
BallisticObject.prototype.isActive = function () {
	return this.active;
}


// === Beam =========================
function Beam(posX, posY, speed, direction, color, lineWidth) {
	// Call parent constructor	
	BallisticObject.call(this, posX, posY, speed, direction);
	this.color = color;
	this.lineWidth = lineWidth;
	this.lines = [];
} // Make it a subclass
Beam.prototype = Object.create(BallisticObject.prototype); 
Beam.prototype.constructor = Beam; 
// updateBEAM()
Beam.prototype.updateBEAM = function () {

	if (this.active){
		// update ballistics
		this.updateOBJ();
		
		// update beam path
		if (this.getDirection() != this.getPrevDirection()) { // create new line
			this.newLine();
		} else {   // update most recent line
			this.lines[this.lines.length - 1].setEnd(this.getX(), 
								 this.getY());
		}
		// check if core collision
		for (var i=0; i < cores.length; i++) {
			core = cores[i];
			if (core.encloses(this.getX(), this.getY())){
				core.absorb(this);
				this.fade();
				break;
			}
		}
	}
}
// activate()
Beam.prototype.activate = function () {
	this.active = true;
	this.newLine();
}
// newLine()
Beam.prototype.newLine = function () {
	var new_line = new Line(this.getX(), this.getY(), 
			    this.getX(), this.getY(), 
			    this.color, this.lineWidth);
	this.lines.push(new_line);
}
// fade()
Beam.prototype.fade = function () {
	this.lines = [];
}
// draw()
Beam.prototype.draw = function () {
	for(var i=0; i < this.lines.length; i++) {
		this.lines[i].draw();
	}
}




// === Pulse =========================
function Pulse(posX, posY, speed, direction, trailLength, color, lineWidth) {
	// Call parent constructor	
	BallisticObject.call(this, posX, posY, speed, direction);
	this.trail = new Trail(this, trailLength, color, lineWidth);
} // Make it a subclass
Pulse.prototype = Object.create(BallisticObject.prototype); 
Pulse.prototype.constructor = Pulse; 
// updatePULSE()
Pulse.prototype.updatePULSE = function () {
	if (this.active){
		this.updateOBJ();
		this.trail.updateTRAIL();
	}
}
// draw()
Pulse.prototype.draw = function () {
	this.trail.draw();
}


// ----------------------------------
// Cores and Sources
// ----------------------------------

// === Core =========================
function Core(centerX, centerY, innerRadius, outerRadius, color, coreRings) {
	this.centerX = centerX;
	this.centerY = centerY;
	this.innerRadius = innerRadius;
	this.outerRadius = outerRadius;
	this.color = color;
	this.coreRings = coreRings; // an array of CoreRing objects
}
// updateCORE()
Core.prototype.updateCORE = function () {

	for (var i=0; i < this.coreRings.length; i++) {	
		this.coreRings[i].updateRING();	 // update each ring
	}	
}
// isFull()
Core.prototype.isFull = function () {
	for (var i=0; i < this.coreRings.length; i++) {
		if (!(this.coreRings[i].isActive())) {
			return false;
		}
	}
	return true;
}
// explode()
Core.prototype.explode = function () {
	for (var i=0; i < this.coreRings.length; i++) {
		var ring = this.coreRings[i];
		if (ring.isActive()) {
			ring.deactivate();
			// fire laser beam
			
			// TODO
		} else {
			ring.activate();
		}
	}
}
// absorb()
Core.prototype.absorb = function (beam) {
	var absorbed = false;
	for (var i=0; i < this.coreRings.length; i++) {
		var ring = this.coreRings[i];
		if (!(ring.isActive()) && beam.color == ring.color) {
			ring.activate();
			return;
		}
	}
	if (!absorbed) {
		// broken core
		// TO DO
		return;
	}
}
// getX()
Core.prototype.getX = function () {
	return this.centerX;
}
// getY()
Core.prototype.getY = function () {
	return this.centerY;
}
// encloses()
Core.prototype.encloses = function (x, y) {
	// Call helper function
	var dist = distance_between_two_points(this.centerX, this.centerY, x, y);
	return Boolean(this.outerRadius - dist > 0);
}
// draw()
Core.prototype.draw = function () {
	
	// Core circle
	colorCircle(this.centerX, this.centerY, this.innerRadius, this.color);
	
	// Core levels
	for(var i=0; i < this.coreRings.length; i++){
		var ring = this.coreRings[i];
		if (ring.isActive()) {
			ring.draw(this.centerX, this.centerY);
		}
	}
}


// === CoreRing =========================
function CoreRing(radius, frequency, amplitude, color, lineWidth) {
	this.radius = radius;
	this.frequency = frequency;
	this.amplitude = amplitude;
	this.radiusChange = 0; 
	this.degreeOffset = 0; // 0-359 degrees
	this.active = false;
	
	this.color = color;
	this.lineWidth = lineWidth;	
}
// updateRING()
CoreRing.prototype.updateRING = function () {
	if (this.active){
		this.degreeOffset = (this.degreeOffset + this.frequency) % 360;
		// var radiansOffset = this.degreeOffset * Math.PI/180;
		this.radiusChange = this.amplitude * Math.sin(this.degreeOffset);
	}
}
// isActive()
CoreRing.prototype.isActive = function () {
	return this.active;
}
// activate()
CoreRing.prototype.activate = function () {
	this.active = true;
}
// deactivate()
CoreRing.prototype.deactivate = function () {
	this.active = false;
}
// getColor()
CoreRing.prototype.getColor = function () {
	return this.color;
}
// draw()
CoreRing.prototype.draw = function (centerX, centerY) {
	var rad = this.radius + this.radiusChange;
	strokeCircle(centerX, centerY, rad, this.color, this.lineWidth);
}



// ------------------------------------

// ##################################
// Gameplay
// ##################################



// Mirrors
var mirrorLineWidth = 6;
var mirror1 = new MirrorLine(0, 400, 500, 0, 'gray', mirrorLineWidth);

var mirrors = [mirror1];

// @@@@@@@@@@@@@@@@@@
console.log(mirrors);
// @@@@@@@@@@@@@@@@@@


//Cores

var dashLineWidth = 2;

var pos1x = 50;
var pos1y = 50;
var angle1 = 45;
var dash1 = 2;
var CR1 = new CoreRing(20, .04, 1, 'red', 3);
CR1.activate();
var arr1 = [CR1];
var pulse1 = new Pulse(pos1x,pos1y, LIGHTSPEED, angle1, dash1, 'red', dashLineWidth);
pulse1.activate();
var core1 = new Core(pos1x, pos1y, 7, 20, 'red', arr1);


var pos2x = 200;
var pos2y = 300;
var angle2 = 0;
var dash2 = 5;
var CR2 = new CoreRing(25, .08, 1, 'green', 5);
CR2.activate();
var arr2 = [CR2];
var pulse2 = new Pulse(pos2x,pos2y, LIGHTSPEED, angle2, dash2, 'green', dashLineWidth);
pulse2.activate();
var core2 = new Core(pos2x, pos2y, 10, 20, 'green', arr2);

var pos3x = 250;
var pos3y = 50;
var angle3 = 90;
var dash3 = 10;
var CR3r = new CoreRing(20, .04, 1, 'red', 3);
CR3r.activate();
var CR3b = new CoreRing(40, .1, 1, 'blue', 5);
CR3b.activate();
var arr3 = [CR3b, CR3r];
var pulse3 = new Pulse(pos3x,pos3y, LIGHTSPEED, angle3, dash3, 'purple', dashLineWidth);
pulse3.activate();
var core3 = new Core(pos3x, pos3y, 10, 20, 'purple', arr3);


var beam1 = new Beam(50,300, LIGHTSPEED, 270, 'red', dashLineWidth);
beam1.activate();
var beam2 = new Beam(50,300, LIGHTSPEED, 0, 'green', dashLineWidth);
beam2.activate();
var beam3 = new Beam(50,300, LIGHTSPEED, 315, 'purple', dashLineWidth);
beam3.activate();


//Accumulate

var cores = [core2, core1, core3];
var beams = []; //[beam1, beam2, beam3];
var pulses = [pulse1, pulse2, pulse3];

// @@@@@@@@@@@@@@@@@@
console.log(cores);
// @@@@@@@@@@@@@@@@@@


function moveEverything() {
	
	// ---------------------
	// Ballistic objects
	// ---------------------
	
	
	// Beams
	for (var i=0; i < beams.length; i++) {
		beams[i].updateBEAM();
	}
	// Pulses
	for (var i=0; i < pulses.length; i++) {
		pulses[i].updatePULSE();
	}
	
	// ---------------------
	// Mouse tractor beam 
	// ---------------------
	
	
	// ---------------------
	// CORES
	// ---------------------
	// update core rings
	for (var i=0; i < cores.length; i++) {
		cores[i].updateCORE();
	}
}


// ##################################
// DRAW
// ##################################

function drawEverything() {
	// next line blanks out the screen with black
	colorRect(0,0,canvas.width,canvas.height,'black');
	
	// Cores
	for (var i=0; i < cores.length; i++) {
		cores[i].draw();
	}
	
	
	// Beams
	for (var i=0; i < beams.length; i++) {
		beams[i].draw();
	}
	// Pulses
	for (var i=0; i < pulses.length; i++) {
		pulses[i].draw();
	}
	// Mirrors
	for (var i=0; i < mirrors.length; i++) {
		mirrors[i].draw();
	}
}

// Draws line on canvas from (x0, y0) to (x1, y1)
function colorLine(x0, y0, x1, y1, drawColor, lineWidth) {
	ctx.strokeStyle = drawColor;
	ctx.lineWidth = lineWidth;
	
	ctx.beginPath();
	ctx.moveTo(x0, y0);
	ctx.lineTo(x1, y1);
	ctx.stroke();
	ctx.lineCap="round";
}


function colorCircle(centerX, centerY, radius, drawColor) {
	ctx.fillStyle = drawColor;
	ctx.beginPath();
	ctx.arc(centerX, centerY, radius, 0, Math.PI*2,true);
	ctx.fill();
}

function strokeCircle(centerX, centerY, radius, drawColor, lineWidth) {
	ctx.strokeStyle = drawColor;
	ctx.lineWidth = lineWidth;
	
	ctx.beginPath();
	ctx.arc(centerX, centerY, radius, 0, Math.PI*2,true);
	ctx.stroke();
}

function colorRect(leftX, topY, width, height, drawColor) {
	ctx.fillStyle = drawColor;
	ctx.fillRect(leftX, topY, width, height);
}



</script>

</html>